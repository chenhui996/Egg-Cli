# lerna-初始化过程源码分析

- 把 lerna 整个执行的流程，捋一捋。

> IDE: WebStorem

## lerna deBug 配置

- Preferences -> Node.js -> <deBug-name> -> Node parameters: **core/lerna/cli.js ls**

> 顺着 lerna ls，了解 lerna 的整个执行流程（debug）。

## start

进入 lerna 源码入口（cli.js） -> 找到引用 importLocal 处 -> **打上断点，点击 degug**

```js
// ./cli.js

6     const importLocal = require('import-local')
// ...
```

> importLocal 后面会重点分析，此处先跳过（F8 Step over）。

```js
// ./cli.js
//...

8    if (importLocal(__filename)) {
9      require('npmlog').info('cli'， 'using local version of lerna')
10   } else {
11     require('.')(process.argv.slice(2))
12   }

```

- 现象：
  - 从 start 处的 importLocal 执行 F8，会进入 8 行。
  - 再次执行 F8，不会进入 第 9 行，而是直接进入 11 行。
- 分析：
  - 第 8 行返回 false ，故 F8 将不会 into 执行。
  - F8 将直接继续向下执行。
    - **于是就来到第 11 行。**

### require(".")

看到第 11 行：

```js
// ./cli.js
// ...

11    require('.')(process.argv.slice(2))
```

- 问题：
  - `require('.')` 是什么意思？
  - 一般不是 `require('./index.js')`，类似这种形式的吗？
  - 跟一个点是麻玩意？
- 分析：
  - 这种形式，表示相对路径。
    - `.`表示当前目录。
      - 后面不跟内容 -> 默认寻找 index.js。
      - 故`.` 等价于 `./index.js`
    - `../` 表示上层目录。
      - 同理，`../` 等价于 `../index.js`。

#### 实际执行：

- `require(".")` 代表：
  - 进入 `./index.js` 文件内：
    - 找到 `exports` 的目标:

```js
// ./index.js
// ...

23    module.exports = main;
// ...
```

- 回看到之前入口文件的第 11 行：

```js
// ./cli.js
// ...

11    require('.')(process.argv.slice(2))
```

- require 后面紧跟 (),代表立即执行。
  - ()内的内容为执行参数。
- 执行解析：
  - 找到 `./index.js` 文件内的 `exports` 目标 -> 此处为 `main`。
  - 立即执行 `main` 方法，并且将 `process.argv.slice(2)` 作为函数参数传入。

---

### process.argv.slice(2)

- 代表我们执行指令：
  - 从第三个参数往后的所有指令。
  - 当前栈中的执行指令：
    - 0： `node`
    - 1： `lerna`
    - 2： `ls`
- 于是我们取到的指令为： `ls`

> 此次源码分析，就是基于 `ls` 进行查阅学习分析的。

---

### 依次逐行执行

- 疑问： `require(".")`的含义上面已详细阐述。
  - 但是，程序是如何找到 `module.exports = main` 的呢？
- 解答：程序执行是 "依次逐行执行":
  - `require(".")`代表执行 `./index.js` -> 进入 `./index.js` 后进行 **依次逐行执行** -> 最终找到 `module.exports = main`。

---

### 跳转依赖包执行

```js
// ./index.js (全代码)
'use strict'

const cli = require('@lerna/cli')

const addCmd = require('@lerna/add/command')
const bootstrapCmd = require('@lerna/bootstrap/command')
const changedCmd = require('@lerna/changed/command')
const cleanCmd = require('@lerna/clean/command')
const createCmd = require('@lerna/create/command')
const diffCmd = require('@lerna/diff/command')
const execCmd = require('@lerna/exec/command')
const importCmd = require('@lerna/import/command')
const infoCmd = require('@lerna/info/command')
const initCmd = require('@lerna/init/command')
const linkCmd = require('@lerna/link/command')
const listCmd = require('@lerna/list/command')
const publishCmd = require('@lerna/publish/command')
const runCmd = require('@lerna/run/command')
const versionCmd = require('@lerna/version/command')

const pkg = require('./package.json')

module.exports = main

function main(argv) {
  const context = {
    lernaVersion: pkg.version,
  }

  return cli()
    .command(addCmd)
    .command(bootstrapCmd)
    .command(changedCmd)
    .command(cleanCmd)
    .command(createCmd)
    .command(diffCmd)
    .command(execCmd)
    .command(importCmd)
    .command(infoCmd)
    .command(initCmd)
    .command(linkCmd)
    .command(listCmd)
    .command(publishCmd)
    .command(runCmd)
    .command(versionCmd)
    .parse(argv, context)
}
```

- 在进入 `./index.js` 进行逐行执行时：
  - 若执行到类似 `const cli = require("@lerna/cli")` 这种含其他依赖包的引用时。
    - 会跳转至相应的包进行执行，如：
      - 此处会跳转至 `@lerna/cli` 这个包进行执行。
      - 执行完后，在回来，再向下进行执行。
  - 其他同理可的。

> 用读书时的一句话 -> 易证。（皮一下）

## 小总结

- lerna 基本的代码执行方式，就是上述方式。
- 接下来的文档撰写，将不会像上述那样详细。

---
